{
  "_metadata": {
    "node_type": "agentAgentflow",
    "name": "agentAgentflow",
    "label": "Meeting Booking Agent - Execution",
    "category": "Agent Flows",
    "version": 2.2,
    "description": "Dynamically choose and utilize tools during runtime, enabling multi-step reasoning",
    "base_classes": [
      "Agent"
    ],
    "extracted_date": "2025-10-17",
    "source": "Flowise instance",
    "usage_note": "Replace ID and customize inputs before use"
  },
  "node": {
    "id": "agentAgentflow_0",
    "position": {
      "x": 294.4258580520767,
      "y": -161.48538093273814
    },
    "data": {
      "loadMethods": {},
      "label": "Meeting Booking Agent - Execution",
      "name": "agentAgentflow",
      "version": 2.2,
      "type": "Agent",
      "category": "Agent Flows",
      "description": "Dynamically choose and utilize tools during runtime, enabling multi-step reasoning",
      "color": "#4DD0E1",
      "baseClasses": [
        "Agent"
      ],
      "inputs": {
        "agentModel": "chatOpenAI",
        "agentMessages": [
          {
            "role": "system",
            "content": "<p>You receive Slack events that require calendar action. Book meetings and respond.</p><hr><p>input_data = <span class=\"variable\" data-type=\"mention\" data-id=\"$flow.state.slack_message\" data-label=\"$flow.state.slack_message\">{{ $flow.state.slack_message }}</span> </p><hr><h2>INPUT FORMAT</h2><pre><code class=\"language-json\">{\n  \"event\": {\n    \"user\": \"U123ABC\",\n    \"text\": \"&lt;@BOT_ID&gt; meeting with &lt;@USER_ID&gt; at 4pm today\",\n    \"channel\": \"C456DEF\",\n    \"ts\": \"1234567890.123456\",\n    \"thread_ts\": null\n  }\n}\n</code></pre><hr><h2>YOUR WORKFLOW</h2><ol><li><p><strong>Extract ALL attendees</strong> from text:</p><ul><li><p>Slack mentions: <code>&lt;@USER_ID&gt;</code> \u2192 call <code>slack_get_user_profile</code> to get email</p></li><li><p>Plain emails: <code>john@gmail.com</code>, <code>sarah@company.com</code> \u2192 use directly</p></li><li><p>Requester: <code>event.user</code> \u2192 call <code>slack_get_user_profile</code> to get email</p></li></ul></li><li><p><strong>Combine all emails</strong> into attendees list (no duplicates)</p></li><li><p><strong>Parse time/date</strong> from text (handle \"today\", \"tomorrow\", \"4pm\", etc.)</p></li><li><p><strong>Book meeting</strong> via <code>google_calendar_create_event</code> with ALL attendees</p></li><li><p><strong>Respond in thread</strong> via <code>slack_send_message</code></p></li></ol><hr><h2>EXTRACTING ATTENDEES - CRITICAL</h2><h3>Pattern 1: Slack Mentions</h3><p>Format: <code>&lt;@USER_ID&gt;</code> (e.g., <code>&lt;@U08Q98M0YCQ&gt;</code>)</p><p><strong>Action:</strong></p><ol><li><p>Extract user ID from pattern</p></li><li><p>Call <code>slack_get_user_profile(user_id)</code></p></li><li><p>Get email from response</p></li><li><p>Add to attendees list</p></li></ol><h3>Pattern 2: Plain Email Addresses</h3><p>Format: <code>user@domain.com</code> (e.g., <code>john@gmail.com</code>, <code>client@company.com</code>)</p><p><strong>Action:</strong></p><ol><li><p>Extract email using regex: <code>[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}</code></p></li><li><p>Add directly to attendees list (no profile lookup needed)</p></li><li><p>Works with ANY domain: gmail.com, yahoo.com, external companies, etc.</p></li></ol><h3>Pattern 3: Requester (Always Include)</h3><p>The person who sent the message is ALWAYS an attendee</p><p><strong>Action:</strong></p><ol><li><p>Get <code>event.user</code> from input</p></li><li><p>Call <code>slack_get_user_profile(event.user)</code></p></li><li><p>Add their email to attendees list</p></li></ol><h3>Combining All Attendees</h3><p><strong>Final attendees list = [requester_email, ...slack_mention_emails, ...plain_emails]</strong></p><p>Remove duplicates if same email appears multiple times.</p><hr><h2>THREAD RULES</h2><p><strong>ALWAYS reply in threads:</strong></p><ul><li><p>If <code>event.thread_ts</code> exists \u2192 use it</p></li><li><p>If <code>event.thread_ts</code> is null \u2192 use <code>event.ts</code> (start new thread)</p></li><li><p>NEVER respond without <code>thread_ts</code></p></li></ul><hr><h2>TOOLS</h2><h3>slack_get_user_profile(user_id)</h3><p>Returns: <code>{\"email\": \"user@company.com\"}</code></p><h3>google_calendar_create_event(title, start_time, end_time, attendees)</h3><p>Returns: <code>{\"event_id\": \"abc123\"}</code></p><h3>slack_send_message(channel, thread_ts, text)</h3><p>Sends response to Slack thread</p><p><strong>CRITICAL:</strong> You MUST call <code>slack_send_message</code> to respond. Text output alone won't appear in Slack.</p><hr><h2>RESPONSE FORMAT</h2><pre><code>\u2705 **Meeting booked!**\n\n\ud83d\udcc5 [Date/time]\n\u23f0 [Duration]\n\ud83d\udc65 &lt;@USER_ID&gt; john@gmail.com sarah@company.com\n\nCalendar invite sent to all attendees.\n</code></pre><p><strong>Format rules:</strong></p><ul><li><p>Use Slack mentions <code>&lt;@USER_ID&gt;</code> for internal users (they get notified)</p></li><li><p>Use plain emails for external users (e.g., john@gmail.com)</p></li><li><p>List all attendees clearly</p></li></ul><hr><h2>EXAMPLE</h2><p><strong>Input:</strong></p><pre><code class=\"language-json\">{\n  \"event\": {\n    \"user\": \"U111\",\n    \"text\": \"&lt;@BOT&gt; meeting with &lt;@U222&gt; and john@gmail.com at 4pm today\",\n    \"channel\": \"C333\",\n    \"ts\": \"1234567890.123456\"\n  }\n}\n</code></pre><p><strong>Actions:</strong></p><ol><li><p>Extract attendees from text:</p><ul><li><p>Slack mention: <code>&lt;@U222&gt;</code> \u2192 call <code>slack_get_user_profile(U222)</code> \u2192 invitee@company.com</p></li><li><p>Plain email: <code>john@gmail.com</code> \u2192 use directly</p></li><li><p>Requester: <code>U111</code> \u2192 call <code>slack_get_user_profile(U111)</code> \u2192 requester@company.com</p></li></ul></li><li><p>Combined attendees: <code>[\"requester@company.com\", \"invitee@company.com\", \"john@gmail.com\"]</code></p></li><li><p>Parse: today 4pm = 2025-10-13 16:00</p></li><li><p>Call: <code>google_calendar_create_event( title=\"Meeting\", start_time=\"2025-10-13T16:00:00-04:00\", end_time=\"2025-10-13T17:00:00-04:00\", attendees=[\"requester@company.com\", \"invitee@company.com\", \"john@gmail.com\"] )</code></p></li><li><p>Call: <code>slack_send_message(channel=\"C333\", thread_ts=\"1234567890.123456\", text=\"\u2705 Meeting booked with invitee@company.com and john@gmail.com ...\")</code></p></li></ol><hr><h2>MORE EXAMPLES</h2><h3>Only emails:</h3><p><strong>Text:</strong> <code>\"book meeting with john@gmail.com and sarah@yahoo.com tomorrow at 2pm\"</code></p><p><strong>Extract:</strong></p><ul><li><p>Requester: event.user \u2192 get via slack_get_user_profile</p></li><li><p>Plain emails: john@gmail.com, sarah@yahoo.com</p></li><li><p>Attendees: [requester@company.com, john@gmail.com, sarah@yahoo.com]</p></li></ul><h3>Only Slack mentions:</h3><p><strong>Text:</strong> <code>\"&lt;@BOT&gt; sync with &lt;@U111&gt; and &lt;@U222&gt; at 3pm\"</code></p><p><strong>Extract:</strong></p><ul><li><p>Requester: event.user \u2192 get via slack_get_user_profile</p></li><li><p>Mentions: U111, U222 \u2192 get emails via slack_get_user_profile</p></li><li><p>Attendees: [requester@company.com, user1@company.com, user2@company.com]</p></li></ul><h3>Mixed:</h3><p><strong>Text:</strong> <code>\"meeting with &lt;@U111&gt; and external-client@gmail.com Friday 10am\"</code></p><p><strong>Extract:</strong></p><ul><li><p>Requester: event.user \u2192 get via slack_get_user_profile</p></li><li><p>Mention: U111 \u2192 get via slack_get_user_profile</p></li><li><p>Plain email: external-client@gmail.com</p></li><li><p>Attendees: [requester@company.com, user1@company.com, external-client@gmail.com]</p></li></ul><hr><h2>DEFAULTS</h2><ul><li><p>Duration: 1 hour</p></li><li><p>Timezone: America/New_York</p></li><li><p>Title: \"Meeting\" (or extract from context)</p></li></ul><hr><p><strong>Remember: ALWAYS call slack_send_message tool. Your response only appears in Slack if you use the tool.</strong></p><p><strong>CRITICAL: Accept ALL email addresses regardless of domain. Gmail.com, yahoo.com, client-company.com - ALL external emails are valid attendees. Add them directly to the calendar invite.</strong></p>"
          }
        ],
        "agentTools": [
          {
            "agentSelectedTool": "googleCalendarTool",
            "agentSelectedToolRequiresHumanInput": "",
            "agentSelectedToolConfig": {
              "credential": "",
              "calendarType": "freebusy",
              "agentSelectedTool": "googleCalendarTool",
              "FLOWISE_CREDENTIAL_ID": "c1597d18-609f-4fd6-97f9-94917f5e2329",
              "freebusyActions": "[\"queryFreebusy\"]",
              "freebusyTimeMin": "15",
              "freebusyTimeMax": "30",
              "calendarIds": "yermek@salemwise.com"
            }
          },
          {
            "agentSelectedTool": "googleCalendarTool",
            "agentSelectedToolRequiresHumanInput": "",
            "agentSelectedToolConfig": {
              "calendarType": "event",
              "agentSelectedTool": "googleCalendarTool",
              "FLOWISE_CREDENTIAL_ID": "c1597d18-609f-4fd6-97f9-94917f5e2329",
              "eventActions": "[\"createEvent\",\"quickAddEvent\",\"listEvents\"]"
            }
          },
          {
            "agentSelectedTool": "currentDateTime",
            "agentSelectedToolRequiresHumanInput": "",
            "agentSelectedToolConfig": {
              "agentSelectedTool": "currentDateTime"
            }
          },
          {
            "agentSelectedTool": "slackMCP",
            "agentSelectedToolRequiresHumanInput": "",
            "agentSelectedToolConfig": {
              "mcpActions": "[\"slack_add_reaction\",\"slack_get_channel_history\",\"slack_get_thread_replies\",\"slack_get_user_profile\",\"slack_get_users\",\"slack_list_channels\",\"slack_post_message\",\"slack_reply_to_thread\"]",
              "agentSelectedTool": "slackMCP",
              "FLOWISE_CREDENTIAL_ID": "e6149abe-09a9-482a-94e9-dbb5aa4dac4a"
            }
          }
        ],
        "agentKnowledgeDocumentStores": "",
        "agentKnowledgeVSEmbeddings": "",
        "agentEnableMemory": true,
        "agentMemoryType": "windowSize",
        "agentUserMessage": "",
        "agentReturnResponseAs": "userMessage",
        "agentUpdateState": "",
        "agentModelConfig": {
          "cache": "",
          "modelName": "gpt-4o-mini",
          "temperature": 0.9,
          "streaming": true,
          "maxTokens": "",
          "topP": "",
          "frequencyPenalty": "",
          "presencePenalty": "",
          "timeout": "",
          "strictToolCalling": "",
          "stopSequence": "",
          "basepath": "",
          "proxyUrl": "",
          "baseOptions": "",
          "allowImageUploads": "",
          "agentModel": "chatOpenAI",
          "FLOWISE_CREDENTIAL_ID": "cce50fc6-ef42-43e8-9bb2-0638c0bf23be"
        },
        "undefined": ""
      },
      "filePath": "/home/yermek/Flowise/packages/server/node_modules/flowise-components/dist/nodes/agentflow/Agent/Agent.js",
      "inputAnchors": [],
      "inputParams": [
        {
          "label": "Model",
          "name": "agentModel",
          "type": "asyncOptions",
          "loadMethod": "listModels",
          "loadConfig": true,
          "id": "agentAgentflow_0-input-agentModel-asyncOptions",
          "display": true
        },
        {
          "label": "Messages",
          "name": "agentMessages",
          "type": "array",
          "optional": true,
          "acceptVariable": true,
          "array": [
            {
              "label": "Role",
              "name": "role",
              "type": "options",
              "options": [
                {
                  "label": "System",
                  "name": "system"
                },
                {
                  "label": "Assistant",
                  "name": "assistant"
                },
                {
                  "label": "Developer",
                  "name": "developer"
                },
                {
                  "label": "User",
                  "name": "user"
                }
              ]
            },
            {
              "label": "Content",
              "name": "content",
              "type": "string",
              "acceptVariable": true,
              "generateInstruction": true,
              "rows": 4
            }
          ],
          "id": "agentAgentflow_0-input-agentMessages-array",
          "display": true
        },
        {
          "label": "OpenAI Built-in Tools",
          "name": "agentToolsBuiltInOpenAI",
          "type": "multiOptions",
          "optional": true,
          "options": [
            {
              "label": "Web Search",
              "name": "web_search_preview",
              "description": "Search the web for the latest information"
            },
            {
              "label": "Code Interpreter",
              "name": "code_interpreter",
              "description": "Write and run Python code in a sandboxed environment"
            },
            {
              "label": "Image Generation",
              "name": "image_generation",
              "description": "Generate images based on a text prompt"
            }
          ],
          "show": {
            "agentModel": "chatOpenAI"
          },
          "id": "agentAgentflow_0-input-agentToolsBuiltInOpenAI-multiOptions",
          "display": true
        },
        {
          "label": "Gemini Built-in Tools",
          "name": "agentToolsBuiltInGemini",
          "type": "multiOptions",
          "optional": true,
          "options": [
            {
              "label": "URL Context",
              "name": "urlContext",
              "description": "Extract content from given URLs"
            },
            {
              "label": "Google Search",
              "name": "googleSearch",
              "description": "Search real-time web content"
            }
          ],
          "show": {
            "agentModel": "chatGoogleGenerativeAI"
          },
          "id": "agentAgentflow_0-input-agentToolsBuiltInGemini-multiOptions",
          "display": false
        },
        {
          "label": "Anthropic Built-in Tools",
          "name": "agentToolsBuiltInAnthropic",
          "type": "multiOptions",
          "optional": true,
          "options": [
            {
              "label": "Web Search",
              "name": "web_search_20250305",
              "description": "Search the web for the latest information"
            },
            {
              "label": "Web Fetch",
              "name": "web_fetch_20250910",
              "description": "Retrieve full content from specified web pages"
            }
          ],
          "show": {
            "agentModel": "chatAnthropic"
          },
          "id": "agentAgentflow_0-input-agentToolsBuiltInAnthropic-multiOptions",
          "display": false
        },
        {
          "label": "Tools",
          "name": "agentTools",
          "type": "array",
          "optional": true,
          "array": [
            {
              "label": "Tool",
              "name": "agentSelectedTool",
              "type": "asyncOptions",
              "loadMethod": "listTools",
              "loadConfig": true
            },
            {
              "label": "Require Human Input",
              "name": "agentSelectedToolRequiresHumanInput",
              "type": "boolean",
              "optional": true
            }
          ],
          "id": "agentAgentflow_0-input-agentTools-array",
          "display": true
        },
        {
          "label": "Knowledge (Document Stores)",
          "name": "agentKnowledgeDocumentStores",
          "type": "array",
          "description": "Give your agent context about different document sources. Document stores must be upserted in advance.",
          "array": [
            {
              "label": "Document Store",
              "name": "documentStore",
              "type": "asyncOptions",
              "loadMethod": "listStores"
            },
            {
              "label": "Describe Knowledge",
              "name": "docStoreDescription",
              "type": "string",
              "generateDocStoreDescription": true,
              "placeholder": "Describe what the knowledge base is about, this is useful for the AI to know when and how to search for correct information",
              "rows": 4
            },
            {
              "label": "Return Source Documents",
              "name": "returnSourceDocuments",
              "type": "boolean",
              "optional": true
            }
          ],
          "optional": true,
          "id": "agentAgentflow_0-input-agentKnowledgeDocumentStores-array",
          "display": true
        },
        {
          "label": "Knowledge (Vector Embeddings)",
          "name": "agentKnowledgeVSEmbeddings",
          "type": "array",
          "description": "Give your agent context about different document sources from existing vector stores and embeddings",
          "array": [
            {
              "label": "Vector Store",
              "name": "vectorStore",
              "type": "asyncOptions",
              "loadMethod": "listVectorStores",
              "loadConfig": true
            },
            {
              "label": "Embedding Model",
              "name": "embeddingModel",
              "type": "asyncOptions",
              "loadMethod": "listEmbeddings",
              "loadConfig": true
            },
            {
              "label": "Knowledge Name",
              "name": "knowledgeName",
              "type": "string",
              "placeholder": "A short name for the knowledge base, this is useful for the AI to know when and how to search for correct information"
            },
            {
              "label": "Describe Knowledge",
              "name": "knowledgeDescription",
              "type": "string",
              "placeholder": "Describe what the knowledge base is about, this is useful for the AI to know when and how to search for correct information",
              "rows": 4
            },
            {
              "label": "Return Source Documents",
              "name": "returnSourceDocuments",
              "type": "boolean",
              "optional": true
            }
          ],
          "optional": true,
          "id": "agentAgentflow_0-input-agentKnowledgeVSEmbeddings-array",
          "display": true
        },
        {
          "label": "Enable Memory",
          "name": "agentEnableMemory",
          "type": "boolean",
          "description": "Enable memory for the conversation thread",
          "default": true,
          "optional": true,
          "id": "agentAgentflow_0-input-agentEnableMemory-boolean",
          "display": true
        },
        {
          "label": "Memory Type",
          "name": "agentMemoryType",
          "type": "options",
          "options": [
            {
              "label": "All Messages",
              "name": "allMessages",
              "description": "Retrieve all messages from the conversation"
            },
            {
              "label": "Window Size",
              "name": "windowSize",
              "description": "Uses a fixed window size to surface the last N messages"
            },
            {
              "label": "Conversation Summary",
              "name": "conversationSummary",
              "description": "Summarizes the whole conversation"
            },
            {
              "label": "Conversation Summary Buffer",
              "name": "conversationSummaryBuffer",
              "description": "Summarize conversations once token limit is reached. Default to 2000"
            }
          ],
          "optional": true,
          "default": "allMessages",
          "show": {
            "agentEnableMemory": true
          },
          "id": "agentAgentflow_0-input-agentMemoryType-options",
          "display": true
        },
        {
          "label": "Window Size",
          "name": "agentMemoryWindowSize",
          "type": "number",
          "default": "20",
          "description": "Uses a fixed window size to surface the last N messages",
          "show": {
            "agentMemoryType": "windowSize"
          },
          "id": "agentAgentflow_0-input-agentMemoryWindowSize-number",
          "display": true
        },
        {
          "label": "Max Token Limit",
          "name": "agentMemoryMaxTokenLimit",
          "type": "number",
          "default": "2000",
          "description": "Summarize conversations once token limit is reached. Default to 2000",
          "show": {
            "agentMemoryType": "conversationSummaryBuffer"
          },
          "id": "agentAgentflow_0-input-agentMemoryMaxTokenLimit-number",
          "display": false
        },
        {
          "label": "Input Message",
          "name": "agentUserMessage",
          "type": "string",
          "description": "Add an input message as user message at the end of the conversation",
          "rows": 4,
          "optional": true,
          "acceptVariable": true,
          "show": {
            "agentEnableMemory": true
          },
          "id": "agentAgentflow_0-input-agentUserMessage-string",
          "display": true
        },
        {
          "label": "Return Response As",
          "name": "agentReturnResponseAs",
          "type": "options",
          "options": [
            {
              "label": "User Message",
              "name": "userMessage"
            },
            {
              "label": "Assistant Message",
              "name": "assistantMessage"
            }
          ],
          "default": "userMessage",
          "id": "agentAgentflow_0-input-agentReturnResponseAs-options",
          "display": true
        },
        {
          "label": "Update Flow State",
          "name": "agentUpdateState",
          "description": "Update runtime state during the execution of the workflow",
          "type": "array",
          "optional": true,
          "acceptVariable": true,
          "array": [
            {
              "label": "Key",
              "name": "key",
              "type": "asyncOptions",
              "loadMethod": "listRuntimeStateKeys",
              "freeSolo": true
            },
            {
              "label": "Value",
              "name": "value",
              "type": "string",
              "acceptVariable": true,
              "acceptNodeOutputAsVariable": true
            }
          ],
          "id": "agentAgentflow_0-input-agentUpdateState-array",
          "display": true
        }
      ],
      "outputs": {},
      "outputAnchors": [
        {
          "id": "agentAgentflow_0-output-agentAgentflow",
          "label": "Agent",
          "name": "agentAgentflow"
        }
      ],
      "id": "agentAgentflow_0",
      "selected": false
    },
    "type": "agentFlow",
    "width": 302,
    "height": 100,
    "selected": true,
    "dragging": false,
    "positionAbsolute": {
      "x": 294.4258580520767,
      "y": -161.48538093273814
    }
  }
}